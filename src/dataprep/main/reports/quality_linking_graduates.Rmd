---
title: "Performance of linking graduates"
author: "Flavio & Christoph & Mona"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  pdf_document:
    toc: true
    toc_depth: 3
---
This script makes some plots of the links. But not all fields complete

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
set.seed(1234)
```

```{r, echo = FALSE, include = FALSE}
packages <- c("tidyverse", "broom", "dbplyr", "RSQLite", "ggplot2", "stringdist")

lapply(packages, library, character.only = TRUE)

datapath <- "/mnt/ssd/"
db_file  <- paste0(datapath, "AcademicGraph/AcademicGraph.sqlite")


 select_fields <- c("biology",
                    "business",
                    "chemistry",
                    "computer science" ,
                    "economics",
                    "engineering",
                    "environmental science",
                    "geography",
                    "geology" ,
                    "history",
                    "materials science",
                    "mathematics",
                    "physics",
                    "political science",
                    "philosophy",
                    "psychology" ,
                    "sociology") # art, medicine linked but not included yet
```

```{r}
# ## db connection
con <- DBI::dbConnect(RSQLite::SQLite(), db_file)
cat("The database connection is: \n")
src_dbi(con)
```


Problem: relationship_id in Christoph's files is not the same as grantid_authorposition in Mona's 
```{r}
# Function to process the data for a specific field
field <- c("sociology")
#"biology", "business", "chemistry", "computer science", "economics", "engineering", "environmental science", "geography", "geology", "history", "materials science", "mathematics", "philosophy", "physics", "political science", "psychology", "sociology"

  
  # Read the data for the specified field
  links_graduates_mona <- read.csv(paste0("/mnt/ssd/linked_ids_temp/links_graduates_", field, "_mona_degree0_19852015.csv"))
   # rename(relationship_id = grantid_authorposition)

  links_graduates_christoph <- read.csv(paste0("/mnt/ssd/linked_ids_temp/links_advisors_", field, "_christoph_degree0_19902015.csv"))

  linked_graduates_mona <- collect(links_graduates_mona)
  linked_graduates_christoph <- collect(links_graduates_christoph)

  # Perform the left join
  linked_graduates <- linked_graduates_mona %>%
    left_join(linked_graduates_christoph, by = c("AuthorId")) %>%
    mutate(difference = ifelse(!is.na(link_score.x) & !is.na(link_score.y), link_score.x - link_score.y, NA))
  
  linked_graduates %>%
    ggplot(aes(x = difference)) +
    geom_histogram(bins = 100, aes(y = after_stat(density))) 
```


```{r, include = FALSE}
DBI::dbDisconnect(con)
```







```{r}
linked_advisors_maths <- linked_advisors_maths  %>% mutate(difference = ifelse(!is.na(link_score.x) & !is.na(link_score.y), link_score.x - link_score.y, NA))
linked_advisors_maths %>%
   ggplot(aes(x = difference)) +
  geom_histogram(bins = 100, aes( y = after_stat(density)))
```









## Overview




```{r}
linked_grants <- collect(linked_grants)
grants <- collect(grants)
linking_info <- collect(linking_info)
```


## Linking scores 
- conditioning on link score > 0.7 is fine

```{r}

linked_grants %>%
  left_join(linking_info, by = "iteration_id") %>%
  filter(link_score>=0.7) %>%
  ggplot(aes(x = link_score)) +
  geom_histogram(bins = 100, aes( y = after_stat(density))) +
  facet_wrap(~field)
  
```

## Link performance by graduation year: so far only for geology

- fraction of grants where the link_score is above the treshold
- the mean link score for grants where dedupe finds a link (link_score is not NA)
- in the figure above, we used the field from iteration_id, but this only works for grants that dedupe suggests to be a link 

```{r}
keep_fields <- select_fields
# c("biology", "chemistry", "computer science", 
#                 "economics", "engineering", "environmental science", 
#                 "geography", "geology", "mathetmatics", "physics",
#                 "political science", "psychology", "sociology")


score_by_year <- grants %>% 
   left_join(linked_grants,
           by = "grantid_authorposition")%>% 
   filter(year >= 1980) #%>%
   #filter(link_score>=0.7) #%>%
   filter(field %in% keep_fields)



#New: linked_grants_share is share of linked grants to total number of grants 
# add restriction of only keeping GrantID with highest score if GrantID exists several times?

score_by_year %>%
  mutate(link_score_adj = ifelse(is.na(link_score), -1, link_score)) %>%
  group_by(year) %>%
  #p50_score = quantile(link_score, probs = 0.5),
 summarise(grants_total = n_distinct(GrantID),
            mean_score = mean(link_score, na.rm = TRUE),
            share_linked = mean(link_score_adj > min_score_grants),
            .groups = "drop") %>%
 filter(link_score > min_score_grants) %>%
  summarise(ngrants_linked = n_distinct(GrantID),
             .groups = "drop") %>%
  summarise(linked_grants_share=ngrants_linked/grants_total)
  pivot_longer(cols = all_of(c("linked_grants_share", "mean_score", "share_linked")),
               names_to = "stat") %>%
  ggplot(aes(x = year, y = value)) +
  geom_line(aes(linetype = stat)) +
  facet_wrap(~field) +
  theme(legend.position = "bottom")

# Don't really understand old code below
# Share link is not really the share of linked grants or is it? 
# Why share linked < mean_score if restriction to link_score>0.7?

# score_by_year %>%
#   mutate(link_score_adj = ifelse(is.na(link_score), -1, link_score)) %>%
#   group_by(year) %>%
#   #p50_score = quantile(link_score, probs = 0.5),
#   summarise(mean_score = mean(link_score, na.rm = TRUE),
#             share_linked = mean(link_score_adj > min_score_grants),
#             .groups = "drop") %>%
#   pivot_longer(cols = all_of(c("mean_score", "share_linked")),
#                names_to = "stat") %>%
#   ggplot(aes(x = year, y = value)) +
#   geom_line(aes(linetype = stat)) +
#   facet_wrap(~field) +
#   theme(legend.position = "bottom")
```



```{r, include = FALSE}
DBI::dbDisconnect(con)
```